
# 可复用设计方法总结
## 静态
	特点，编译期确定功能，抽象来说就是具体函数调用
	比如：
		函数调用
		继承 无虚函数

## 动态
	特点：运气期才确定函数 和 对象（数据）的调用。
	继承 虚函数 （可用继承，组合方式组织起来）
	函数指针
	
## 泛型编程
	特点，编译期确定功能，对类的抽象。
	编码调用期才确定具体功能

# 函数功能 太分散不是好设计
	尽量避免比较简短代码 封一个函数
	坏例子，void SetMem(int i){m_i=i;},  还不如直接public : int m_i;

# 多类型对象碰撞虚拟函数实现

Class B //base class
{
friend void RegMapToFun(void *p);
	private:
		static uint16_t id; //my class id, 0 is not initial

};

uint16_t B::id = 0;


std::map<uint32_t, void *> gM;
template<class T1,  class T2>
void RegMapToFun(void *p)
{
	static uint16_t idSeed = 0;
	if(T1::id == 0)
	{
		T1::id = ++idSeed;
	}
	if(T2::id == 0)
	{
		T2::id = ++idSeed;
	}

	gM.insert({ T2::id<<16 | T1::id,  p });
	gM.insert({T1::id<<16 | T2::id,  p });
}

void Call(B*p1, B*p2)
{

	auto it = gM.find( p1->id<<16 | p2->id);
	if（it == gm.end())
	{
		return;
	}
	(*(it->second))();
}

RegMapToFun<B, C>(nullptr); //注册B,C两种类型碰撞处理方法
Call(B*p1, B*p2); //调用动态处理方法

